- Client-server architecture was considered revolutionary, HOW CAN WE LET 2 PIECES OF CODE IN DIFFERENT LOCATIONS TALK TO EACH OTHER?
- We don't now need ==mainframe computer== that contains everything
	- Mainframe computer  is a high-performance, large-scale, and highly reliable computer
- We can split our mainframe to a client (with cheap hardware) and a good enough server for ==heavy/expensive work==
	- Expensive work is work that takes a lot of resources (RAM / memory / CPU / etc...) or even a lot of time
- We can say that microservices kinda inherited from that model
	- The idea of splitting a big monolith service to multiple microservices and let them talk to each other
	- Clients are lighter
		- They don't require server dependencies (e.g a web client no longer needs a database driver)
	- Clients are scalable
		- We can horizontally or vertically scale the client without scaling the server and vice-versa
	- We can have multiple clients for one server
	- Clients can still do some lightweight tasks (kinda ==Edge Computing==)
		- Edge computing is a distributed computing model that brings computation and data storage closer to the sources of data (i.e closer to the user in our case) like IoT devices
- We can even consider a 3-tier architecture a special case of client server
- The client will be a light caller that calls the strong resourceful server
- Also, ==RPC== took big advantage from that model, it's actually born from here
	- RPC or Remote Procedural Call is a networking protocol allowing a computer program to execute code on a server or another computer as if it were local, without the developer explicitly coding the network interaction
	- RPC at first had no standards, that's of mean as long as you can call the server you are good. Then other companies tried to standardize the RPC by introducing gRPC, gRPC uses HTTP 2
- With all the benefits of Client-server Architecture, we need a **Communication Model (Standard)**

## Brainstorming with AI
* Can we consider HTTP calls as RPCs?
**Google AI Mode**:
==Yes, **HTTP calls can be used to perform Remote Procedure Calls (RPCs)**==, but it is more accurate to say that RPCs can be _implemented over_ HTTP. 

While HTTP itself is a transport protocol designed for transferring data (often used for REST), it can act as the carrier for RPC mechanisms—like SOAP, JSON-RPC, or gRPC—where the primary goal is to execute a specific function on a remote server. 

Here is a breakdown of why this distinction exists and how they relate:

1. The Core Difference

- **RPC (Remote Procedure Call):** Focuses on **actions or functions**. You call a method like `getUser(id)` on a remote machine.
- **HTTP:** Focuses on **transferring resources**. You ask for a representation of a resource, such as `GET /users/1`. 

2. When HTTP Calls Are RPCs

HTTP calls act as RPCs when they are used to execute a specific, named procedure, usually using the `POST` method to send the procedure name and parameters in the body. 

- **Examples:** JSON-RPC, XML-RPC, and SOAP over HTTP.
- **Modern Example:** gRPC (which uses HTTP/2) is designed specifically for high-performance RPC, using Protobuf to define methods and data. 

3. When HTTP Calls Are NOT RPCs

Standard RESTful HTTP calls are not typically considered RPCs. Instead of calling a function, they use standard HTTP verbs (`GET`, `POST`, `PUT`, `DELETE`) to manipulate resources (e.g., updating a user resource instead of calling an `updateUser()` function). 

Summary Table: RPC over HTTP vs. REST

| Feature      | RPC over HTTP                                                                                                     | REST over HTTP           |
| ------------ | ----------------------------------------------------------------------------------------------------------------- | ------------------------ |
| **Focus**    | Actions/Functions (`doSomething`)                                                                                 | Resources (`/users/1`)   |
| **Methods**  | Usually POST                                                                                                      | GET, POST, PUT, DELETE   |
| **Coupling** | Tight (Client knows function name) **(my comment: not necessarily, we can know the `procedure`'s endpoint name)** | Loose (Client knows URL) |
| **Goal**     | Remote Procedure Call                                                                                             | Resource Manipulation    |

In conclusion, you can use HTTP to perform RPCs, making them a type of "RPC over HTTP". However, not all HTTP calls are designed as RPCs; many are designed as resource-oriented REST calls.

**Personal Recommendation:** Read This [AWS Article about the difference between RPC & REST](https://aws.amazon.com/compare/the-difference-between-rpc-and-rest/). Also, [This Tutorial from RabbitMQ Docs](https://www.rabbitmq.com/tutorials/tutorial-six-python) explains RPC as a concept and shows it's not necessary to be implemented using HTTP

---

