- OSI is Open Systems Interconnection Model
- OSI Model is a critical concept to ANY SOFTWARE ENGINEER
- You don't really need to understand everything in it, but just the 7 layers effectively, and where does your application live (in which layer)
- Why would I care where my app lives?
	- If your app is a bridge between 2 other apps, we really need to know what we're looking at
- OSI Model got some critic, there is also the simplified OSI Model
- Every application lives in one or more layers on OSI Model
	- Examples: LBs, Reverse Proxies, CDNs, API gateways, etc...
- ==Open Systems== Interconnection
	- Open Systems means systems with open communication
---
## Motivation
- New Concept: ==Communication Models==
	- Communication models (e.g., OSI, TCP/IP) provide a conceptual, layered framework for understanding how network functions are structured, whereas protocols (e.g., HTTP, TCP, IP) are the specific, actionable rules and procedures that govern how data is actually transmitted, formatted, and received
- Why do we need a communication model when building applications that interacts with a network medium?
	- To build agnostic apps (application doesn't have to know which medium is it building for) that follows a standard
	- Imagine building 3 different versions of your app: one for Ethernet, one for LTE, one for Wi-Fi
	- BTW, We build network apps with WORA style (Write Once Run Everywhere), but we are taking this for granted
		- Software can't run on any piece of metal because it needs to convert its bits in a way that matches with the hardware and hits the correct hardware components, that's why we have standardized hardware architecture designs
		- Software can't interact with any other software/hardware that easy, because compiled software needs to convert its bits in a way that matches the medium (radio waves / light waves / electric signals / etc), that's why we have network standards (communication models and protocols)
	- Network Equipment Management
		- With no standard, upgrading network (replacing/adding hardware components) becomes very difficult
		- The beauty of that is, the network is decoupled from its ==network medium==
			- Network medium is the physical/wireless communication channel (cables, airwaves, etc...)
	- Decoupled Innovation
		- Each layer change does not affect other layers
			- E.g. If we changed layer 1 (physical transmission), we don't have to touch layer 2 (passing bits to layer 1)
---
## What are OSI Model Layers?
* 7 Layers each describes a specific networking component
	- Layer 7: Application (HTTP / FTP / gRPC)
		- Backend engineers nowadays doesn't interact with layer 7 directly, their app is usually above layer 7
		- For Network Engineers, it's about data coming in
	- Layer 6: Presentation (==Encoding== - ==Serialization==)
		- Ever sent a request using `axios` or `fetch`? the JSON object needs to be serialized to a string, this happens at here
		- Encoding binary to UTF-8? Also happens here
		- What's the difference between encoding and serialization?
			- Serialization (or Marshalling): Converts an object structure (e.g., a Python dictionary) into a format like JSON, XML, or binary so it can be stored or sent. It focuses on preserving the data structure.
			- Encoding: Converts a stream of data into another format for compatibility or transport, such as transforming a serialized JSON string into UTF-8 bytes for transmission.
			- **Encoding is a super set of serialization**
	- Layer 5: Session (Connection Establishment - TLS)
		- Storing state on the client and a state on the server and manage the session between client and server
		- HTTP is a stateless protocol (no layer 5), TCP is a stateful protocol
		- After the session is destroyed, you can either restart the connection or invalidate it, the session layer checks it
	- Layer 4: Transport (UDP / TCP)
		- Layer 4 and layer 7 are the most important layers you will care about as a backend engineer
		- Layer 4 app means the app is aware of the transport, segments (TCP) and datagrams (UDP)
		- Only TCP, UDP & QUIC (Quick UDP Internet Connections) are the only layer 4 protocols 
		- All other protocols are built on top of TCP/UDP
			- HTTP: TCP
			- HTTP 2: TCP
			- HTTP 3: QUIC
			- QUIC: UDP
			- SMPP (Short Message Peer-to-Peer): TCP
			- SMTP (Simple Mail Transfer Protocol): TCP
			- SSH: TCP
	- Layer 3: Network (IP)
		- No transport concept
		- In layer 4, I am calling ports, in layer 3, I am calling addresses
		- I don't know if the packet arrives or not, but I will tell you if it's bad
	- Layer 2: Data Link (==Frames== - MAC address - Ethernet)
		- Dealing with physical medium and physical network address
		- A Layer 2 frame is the Protocol Data Unit (PDU) used at the Data Link Layer (Layer 2) of the OSI model. It acts as an envelope that encapsulates a packet from the Network Layer (Layer 3) to facilitate node-to-node data transfer between directly connected devices on a local area network (LAN) or similar network segment.
		- No IP Addresses here, only MAC address and Ethernet
		- We send **Frames** in layer 2, we send **Packets** in layer 3, we send **Segments (TCP) / Datagrams (UDP)**  in layer 4
			- Segments and Datagrams can be used interchangeably for UDP
	- Layer 1: Physical (Electric Signals - Fiber - Radio Waves)
		- ones and zeros
---
## Example (Send a POST request)
- Layer 7: Application
	- Invoking the functionality: for example 
	    ```ts
		fetch(api, {
			method: "POST",
			body: {dummy: "data"}
		});
	    ```
- Layer 6: Presentation
	- Serializing JSON to ==flat byte string== 
		- Byte strings is a sequence of characters represented as bytes (numbers from 0 - 255) and not encoded to a character set
		- Flat means contiguous direct sequence of bytes
		- 1 character != 1 byte
		- For example: ðŸš€ has a unicode of **U+1F680** (128640)
			- Convert to binary: 000011111011010000000
			- Use UTF8 Template (Refer to table below)
			- Convert new binaries to hexadecimal, each hexadecimal is a byte now
			- This [Gemini Conversation](https://gemini.google.com/share/82db3e0a6fa9) is explaining the encoding process in a very easy way

| Byte   | Template Pattern | Capacity | After Injection (Binary) | After Injection (Hexadecimal) |
| ------ | ---------------- | -------- | ------------------------ | ----------------------------- |
| Byte 1 | 11110xxx         | 3 bits   | 11110==000==             | F0                            |
| Byte 2 | 10xxxxxx         | 3 bits   | 10==011111==             | 9F                            |
| Byte 3 | 10xxxxxx         | 3 bits   | 10==011010==             | 9A                            |
| Byte 4 | 10xxxxxx         | 3 bits   | 10==000000==             | 80                            |
- Layer 5: Session
	- Request to establish TCP and TLS connections
- Layer 4: Transport
	- Include source and destination ports
	- Send ==SYN request== to port 443 (default port for https)
		- A SYN (Synchronize) request isÂ the initial TCP packet sent from a client to a server to establish a network connection
		- This is the command done by layer 5
- Layer 3: Network
	- SYN is placed an IP packet and adds source and destination IPs
	- DNS resolves the IPs at layer 7: See this [Stack Overflow Answer](https://stackoverflow.com/questions/21654632/at-what-layer-in-the-protocol-stack-does-dns-happen)
- Layer 2: Data Link
	- Each packet goes into a single frame and adds source and destination MAC addresses
	- ==ARP== (Address Resolution Protocol) resolves MAC addresses from IPs
		- ARP asks every device in the network whether their IP is matching the target IP
		- If the IP is matching, it gets its MAC
		- How does ARP find the destination MAC if it's outside the network?
			- It doesn't, if the target IP is outside the current network. The process changes from finding the destination's MAC address to finding your Default Gateway/Router's MAC address
- Layer 1: Physical
	- Each frame is translated to bits (1 & 0) and transferred either as an electric signal (ethernet), radio waves (wi-fi) or light (fiber)
---
## Example (Receive a POST Request)
- Layer 1: Physical
	- Electric signals, radio waves or light is converted to bits
- Layer 2: Data Link
	- Bits assembled to frames, checking if the target MAC address equals the receiver MAC address, we will continue
	- But here is the thing, the source MAC is not necessarily the original sender's MAC, it's the last Broadcaster's MAC (The receiver Gateway if the sender is outside the network)
- Layer 3: Network
	- Frames peeled into Packets. Check if the Destination IP equals the Device IP, if so, continue
- Layer 4: Transport
	- Packets peeled into segments
	- Deliver the segment to the port
	- Deals with congestion control / flow control / retransmission in case of TCP (is it new packet? old packet? etc...)
	- If the Segment is SYN, establish connection and go to session (last layer here)
- Layer 5: Session
	- Connection established
	- We only arrive here when necessary (==3 way handshake== is done)
		- The TCP 3-way handshake is a foundational process in networking used to establish a reliable, connection-oriented session between a client and a server
		- [Explain Like I'm 5: What's 3 way handshake](https://www.reddit.com/r/explainlikeimfive/comments/6vfjhi/eli5in_networking_what_is_the_three_way_handshake/)
- Layer 6: Presentation
	- Deserialize the byte strings into JSON and them to a client-storable object
		- Deserialization and Serialization are independent of each other, that of, Serializing can happen by JS while deserializing can be done by PHP
	- Since Deserialization is done by the client (programming language), many people consider layers 6 and 7 as one layer
- Layer 7: Application
	- Application understands the POST request and your web hook is triggered
---
- Do we have to go ALL THE 7 LAYERS TWICE with every request? No
- Let's animate the examples above
	- **POST REQUEST**: L7 -> L6 -> L5 (No Connection, wait)
		- L5 (Request Session) -> L4 (send SYN) -> L3 -> L2 -> L1 ===> L1 -> L2 -> L3 -> L4 -> L5 (Accept Connection)->L4 (send SYN ACK) -> L3 -> L2 -> L1 ===> L1 -> L2 -> L3 -> L4 -> L5 (Accept) -> L4 (send ACK) -> L3 -> L2 -> L1 ===> L1 -> L2 -> L3 -> L4 -> L5
	- Continue
- Our request may face different components
	- **Switch**: a hardware device that connects multiple devices (computers, printers, servers) within a LAN, acting as a central hub to intelligently direct data traffic. Switches are consisting of L2 only, they use MAC addresses to match
	- **Hub:** similar to switch but operates on Layer 1 only, broadcasts to all devices
	- **Router:** similar to switch but connects different networks (LANs), operates on L3, as it needs IP address to route to different networks
	- **Firewall**: a hardware or software device that decides to allow or deny traffic to a network
		- Operates at least at L4 (needs to read the port), but can be a L7 device (transparent firewall)
		- Transparent Firewall/Proxy acts like it doesn't exist
		- Example for firewalls/proxies: ISP, they can or cannot be transparent
			- Most of the transparent proxies don't go to the application layer even though they are L7 devices because to do this you need to decrypt the session at layer 6, and most of the time you don't have the certificate for this
	- **Proxy:** a device to communicate with the destination on our behalf, why do we need this?
		- Security
		- Anonymity
		- Control (see inbound and outbound traffic)
		- Proxy is a L4 device as well
	- **Reverse Proxies** are similar to proxy, but it's about a device to communicate with client on the server behalf 
	- Load Balancers and CDNs are L7 devices
		- LBs decrypt your request (go to L7) to see where to route it, then encrypt it again, so it's slow
		- **Every CDN is a L7 Reverse Proxy**
	- VPNs are L3 components
		- Change your IP
- Shortcomings of OSI Model
	- Too many layers
	- Hard to argue which layer does what
	- Simpler to deal with layers 5, 6, and 7 as one layer (application)
		- TCP/IP model just does that
---
## TCP / IP Model
- 4 Layers
	- Layer 4: Application (OSI 5, 6, 7)
	- Layer 3: Transport (OSI 4)
	- Layer 2: Internet (OSI 3)
	- Layer 1: Data Link (OSI 2)
	- NO PHYSICAL LAYER